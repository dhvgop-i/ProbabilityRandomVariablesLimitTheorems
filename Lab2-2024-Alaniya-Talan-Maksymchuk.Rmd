---
title: 'P&S-2022: Lab assignment 2'
author: "Alaniya, Talan, Maksymchuk"
output:
  html_document:
    df_print: paged
---

## General comments and instructions

-   Complete solution will give you **4 points** (working code with explanations + oral defense). Submission deadline **November 1, 2023, 22:00**\
-   The report must be prepared as an *R notebook*; you must submit to **cms** both the source *R notebook* **and** the generated html file\
-   At the beginning of the notebook, provide a work-breakdown structure estimating efforts of each team member\
-   For each task, include
    -   problem formulation and discussion (what is a reasonable answer to discuss);\
    -   the corresponding $\mathbf{R}$ code with comments (usually it is just a couple of lines long);\
    -   the statistics obtained (like sample mean or anything else you use to complete the task) as well as histograms etc to illustrate your findings;\
    -   justification of your solution (e.g. refer to the corresponding theorems from probability theory);\
    -   conclusions (e.g. how reliable your answer is, does it agree with common sense expectations etc)\
-   The **team id number** referred to in tasks is the **two-digit** ordinal number of your team on the list. Include the line **set.seed(team id number)** at the beginning of your code to make your calculations reproducible. Also observe that the answers **do** depend on this number!\
-   Take into account that not complying with these instructions may result in point deduction regardless of whether or not your implementation is correct.

------------------------------------------------------------------------

### Task 1

#### In this task, we discuss the $[7,4]$ Hamming code and investigate its reliability. That coding system can correct single errors in the transmission of $4$-bit messages and proceeds as follows:

-   given a message $\mathbf{m} = (a_1 a_2 a_3 a_4)$, we first encode it to a $7$-bit *codeword* $\mathbf{c} = \mathbf{m}G = (x_1 x_2 x_3 x_4 x_5 x_6 x_7)$, where $G$ is a $4\times 7$ *generator* matrix\
-   the codeword $\mathbf{c}$ is transmitted, and $\mathbf{r}$ is the received message\
-   $\mathbf{r}$ is checked for errors by calculating the *syndrome vector* $\mathbf{z} := \mathbf{r} H$, for a $7 \times 3$ *parity-check* matrix $H$\
-   if a single error has occurred in $\mathbf{r}$, then the binary $\mathbf{z} = (z_1 z_2 z_3)$ identifies the wrong bit no. $z_1 + 2 z_2 + 4z_3$; thus $(0 0 0)$ shows there was no error (or more than one), while $(1 1 0 )$ means the third bit (or more than one) got corrupted\
-   if the error was identified, then we flip the corresponding bit in $\mathbf{r}$ to get the corrected $\mathbf{r}^* = (r_1 r_2 r_3 r_4 r_5 r_6 r_7)$;\
-   the decoded message is then $\mathbf{m}^*:= (r_3r_5r_6r_7)$.

#### The **generator** matrix $G$ and the **parity-check** matrix $H$ are given by

$$  
    G := 
    \begin{pmatrix}
        1 & 1 & 1 & 0 & 0 & 0 & 0 \\
        1 & 0 & 0 & 1 & 1 & 0 & 0 \\
        0 & 1 & 0 & 1 & 0 & 1 & 0 \\
        1 & 1 & 0 & 1 & 0 & 0 & 1 \\
    \end{pmatrix},
 \qquad 
    H^\top := \begin{pmatrix}
        1 & 0 & 1 & 0 & 1 & 0 & 1 \\
        0 & 1 & 1 & 0 & 0 & 1 & 1 \\
        0 & 0 & 0 & 1 & 1 & 1 & 1
    \end{pmatrix}
$$

#### Assume that each bit in the transmission $\mathbf{c} \mapsto \mathbf{r}$ gets corrupted independently of the others with probability $p = \mathtt{id}/100$, where $\mathtt{id}$ is your team number. Your task is the following one.

1.  Simulate the encoding-transmission-decoding process $N$ times and find the estimate $\hat p$ of the probability $p^*$ of correct transmission of a single message $\mathbf{m}$. Comment why, for large $N$, $\hat p$ is expected to be close to $p^*$.\
2.  By estimating the standard deviation of the corresponding indicator of success by the standard error of your sample and using the CLT, predict the \emph{confidence} interval $(p^*-\varepsilon, p^* + \varepsilon)$, in which the estimate $\hat p$ falls with probability at least $0.95$.\
3.  What choice of $N$ guarantees that $\varepsilon \le 0.03$?\
4.  Draw the histogram of the number $k = 0,1,2,3,4$ of errors while transmitting a $4$-digit binary message. Do you think it is one of the known distributions?

#### You can (but do not have to) use the chunks we prepared for you

#### First, we set the **id** of the team and define the probability $p$ and the generator and parity-check matrices $G$ and $H$

```{r}
# your team id number 
id <- 41                   ### 40 + team number (1) = 41, as Maksym Zhuk suggested

set.seed(id)
p <- id/100
# matrices G and H
G <- matrix(c(1, 1, 1, 0, 0, 0, 0,
		1, 0, 0, 1, 1, 0, 0,
		0, 1, 0, 1, 0, 1, 0,
		1, 1, 0, 1, 0, 0, 1), nrow = 4, byrow = TRUE)
H <- t(matrix(c(1, 0, 1, 0, 1, 0, 1,
		0, 1, 1, 0, 0, 1, 1,
		0, 0, 0, 1, 1, 1, 1), nrow = 3, byrow = TRUE))
# cat("The matrix G is: \n") 
#G  
#cat("The matrix H is: \n") 
#H
#cat("The product GH must be zero: \n")
#(G%*%H) %%2
```

#### Next, generate the messages

```{r}
# generate N messages
set.seed(id)
message_generator <- function(N) {
  matrix(sample(c(0,1), 4*N, replace = TRUE), nrow = N)
}

N = 100

messages <- message_generator(N)
codewords <- (messages %*% G) %% 2
```

#### Generate random errors; do not forget that they occur with probability $p$! Next, generate the received messages

```{r}
set.seed(id)
errors <- matrix(rbinom(N * 7, size = 1, prob = p), nrow = N)
received <- (codewords + errors) %% 2
```

The next steps include detecting the errors in the received messages, correcting them, and then decoding the obtained messages. After this, you can continue with calculating all the quantities of interest

```{r}
syndrome_vector <- (received %*% H) %% 2

errors_positions <- syndrome_vector[, 1] + 
                   2 * syndrome_vector[, 2] + 
                   4 * syndrome_vector[, 3]

corrected <- received

index_matrix <- cbind(which(errors_positions > 0), 
                      errors_positions[which(errors_positions > 0)])

corrected[index_matrix] <- (corrected[index_matrix] + 1) %% 2
```

For the hamming code probability of having messages correctly restored is $p^* = (1-p)^7 + 7p(1-p)^6$, that the probability of having less then or equal to 1 errors in the message. So for our p = 1/100 we have $p^* = (1-0.01)^7+7\cdot0.01\cdot(1-0.01)^6 \approx 0.99797$ For large N we will have $p^* \approx \hat{p}$ according to the Law of Large Numbers

```{r}
message_restored <- corrected[, c(3, 5, 6, 7)]

errors_per_row <- rowSums(abs(messages - message_restored))

num_correct_messages <- sum(errors_per_row == 0)

p_hat <- num_correct_messages / N

print(paste("Total messages simulated (N):", N))
print(paste("Total messages correctly restored:", num_correct_messages))
print(paste("Estimated probability (p-hat) of correct transmission:", p_hat))
```

As we can see for p = 0.41, N = 100 is not large enough to have $p^*$ close to $\hat{p}$

2.  95% confidence interval for $p^*$ is given by $(\hat{p}-\epsilon, \hat{p}+\epsilon)$, where: $\epsilon = 1.96 \cdot \sqrt{\frac{\hat{p}(1-\hat{p})}{N}}$, so for $\epsilon \le 0.03$ we will have: $0.03 \ge 1.96 \cdot \sqrt{\frac{\hat{p}(1-\hat{p})}{N}} \to N \ge \hat{p}(1-\hat{p})\cdot(1.96/0.03)^2$ so for our $\hat{p} = 0.99$ we will have:

```{r}
N_bound = p_hat*(1-p_hat) * (1.96/0.03)^2
print(paste("N >=", N_bound))
```

3.  The r.v. that counts the number of wrong bits in decoded message does not have any known distribution. It is closest to binomial but it isn't binomial, as it doesn't have independence for binomial distribution (probability that 5 bit being wrong is not independent of the probability of 3 bit being wrong), also we would have an error in the resulting, decoded and corrected message only if 2 or more errors occurred, and this "if" does not fit in any know distrubution.

```{r}
library(ggplot2)

errors_factor <- factor(errors_per_row, levels = 0:4)

plot_data <- data.frame(errors = errors_factor)

ggplot(plot_data, aes(x = errors, fill = errors)) +
  geom_bar(show.legend = FALSE) +
  scale_y_continuous(labels = scales::comma) + # Format y-axis labels
  labs(
    title = paste("Histogram of Decoded Message Errors (k)"),
    subtitle = paste("N =", format(N, scientific = FALSE), "messages, p =", p),
    x = "Number of Errors in 4-bit Message (k)",
    y = "Frequency (Count)"
  ) +
  theme_minimal(base_size = 14)
```

------------------------------------------------------------------------

### Task 2.

In this task, we discuss a real-life process that is well modelled by a Poisson distribution. As you remember, a Poisson random variable describes occurrences of rare events, i.e., counts the number of successes in a large number of independent random experiments. One of the typical examples is the **radioactive decay** process.

Consider a sample of radioactive element of mass $m$, which has a big *half-life period* $T$; it is vitally important to know the probability that during a one second period, the number of nuclei decays will not exceed some critical level $k$. This probability can easily be estimated using the fact that, given the *activity* ${\lambda}$ of the element (i.e., the probability that exactly one nucleus decays in one second) and the number $N$ of atoms in the sample, the random number of decays within a second is well modelled by Poisson distribution with parameter $\mu:=N\lambda$. Next, for the sample of mass $m$, the number of atoms is $N = \frac{m}{M} N_A$, where $N_A = 6 \times 10^{23}$ is the Avogadro constant, and $M$ is the molar (atomic) mass of the element. The activity of the element, $\lambda$, is $\log(2)/T$, where $T$ is measured in seconds.

Assume that a medical laboratory receives $n$ samples of radioactive element ${{}^{137}}\mathtt{Cs}$ (used in radiotherapy) with half-life period $T = 30.1$ years and mass $m = \mathtt{team\, id \,number} \times 10^{-6}$ g each. Denote by $X_1,X_2,\dots,X_n$ the **i.i.d. r.v.**'s counting the number of decays in sample $i$ in one second.

1.  Specify the parameter of the Poisson distribution of $X_i$ (you'll need the atomic mass of *Cesium-137*)\
2.  Show that the distribution of the sample means of $X_1,\dots,X_n$ gets very close to a normal one as $n$ becomes large and identify that normal distribution. To this end,
    -   simulate the realization $x_1,x_2,\dots,x_n$ of the $X_i$ and calculate the sample mean $s=\overline{\mathbf{x}}$;
    -   repeat this $K$ times to get the sample $\mathbf{s}=(s_1,\dots,s_K)$ of means and form the empirical cumulative distribution function $\hat F_{\mathbf{s}}$ of $\mathbf{s}$;
    -   identify $\mu$ and $\sigma^2$ such that the \textbf{c.d.f.} $F$ of $\mathscr{N}(\mu,\sigma^2)$ is close to the \textbf{e.c.d.f.} $\hat F_{\mathbf{s}}$ and plot both **c.d.f.**'s on one graph to visualize their proximity (use the proper scales!);
    -   calculate the maximal difference between the two \textbf{c.d.f.}'s;
    -   consider cases $n = 5$, $n = 10$, $n=50$ and comment on the results.\
3.  Calculate the largest possible value of $n$, for which the total number of decays in one second is less than $8 \times 10^8$ with probability at least $0.95$. To this end,
    -   obtain the theoretical bound on $n$ using Markov inequality, Chernoff bound and Central Limit Theorem, and compare the results;\
    -   simulate the realization $x_1,x_2,\dots,x_n$ of the $X_i$ and calculate the sum $s=x_1 + \cdots +x_n$;
    -   repeat this $K$ times to get the sample $\mathbf{s}=(s_1,\dots,s_K)$ of sums;
    -   calculate the number of elements of the sample which are less than critical value ($8 \times 10^8$) and calculate the empirical probability; comment whether it is close to the desired level $0.95$

```{r}

calculate_poisson_param <- function(team_id, molar_mass_Cs137) {
  N_A <- 6.022e23       # Avogadro
  T_years <- 30.1       # Half-life
  seconds_per_year <- 365.25 * 24 * 60 * 60
  T_seconds <- T_years * seconds_per_year
  m <- team_id * 1e-6
  M <- molar_mass_Cs137
  lambda_activity <- log(2) / T_seconds
  N_atoms <- (m / M) * N_A
  mu <- N_atoms * lambda_activity # Poisson
  return(mu)
}




generate_sample_means <- function(mu, n, K) {

  all_decays <- rpois(n * K, lambda = mu)

  decay_matrix <- matrix(all_decays, nrow = n, ncol = K)
  sample_means <- colMeans(decay_matrix)

  cat(sprintf("Average (K=%d, n=%d): %.4f\n", K, n, mean(sample_means)))

  return(sample_means)
}




plot_cdfs <- function(sample_means, mu, n) {

  mean_normal <- mu
  sd_normal <- sqrt(mu / n)


  ecdf_s <- ecdf(sample_means)

  plot(ecdf_s,
       main = paste("ECDF vs Normal CDF (n =", n, ")"),
       xlab = "Sample average",
       ylab = "Cumulative probability",
       col = "blue",
       verticals = TRUE,
       do.points = FALSE)

  curve(pnorm(x, mean = mean_normal, sd = sd_normal),
        add = TRUE,
        col = "red",
        lwd = 2)

  legend("bottomright", legend = c("ЕCDF", "Normal CDF"),
         col = c("blue", "red"), lty = 1, lwd = c(1, 2))
}



calculate_max_cdf_diff <- function(sample_means, mu, n) {
  mean_normal <- mu
  sd_normal <- sqrt(mu / n)

  ks_result <- ks.test(sample_means + runif(length(sample_means), -1e-6, 1e-6),
                     "pnorm", mean = mean_normal, sd = sd_normal)


  max_diff <- ks_result$statistic

  cat(sprintf("  Max diff CDF (D=%.4f) для n=%d)\n", max_diff, n))
  return(max_diff)
}





calculate_theoretical_n_bounds <- function(mu, critical_sum, probability_threshold) {

  # Марков
  n_markov <- floor((1 - probability_threshold) * critical_sum / mu)

  # Чернов
  a_ch <- mu
  b_ch <- 1.645 * sqrt(mu)
  c_ch <- -critical_sum
  delta_ch <- b_ch^2 - 4 * a_ch * c_ch
  if (delta_ch < 0) {
    n_chernoff <- 0
  } else {

    sqrt_n_chernoff <- (-b_ch + sqrt(delta_ch)) / (2 * a_ch)
    n_chernoff <- floor(sqrt_n_chernoff^2)
  }


  # CLT
  z_score_clt <- qnorm(probability_threshold)
  a_clt <- mu
  b_clt <- z_score_clt * sqrt(mu)
  c_clt <- -critical_sum
  delta_clt <- b_clt^2 - 4 * a_clt * c_clt
   if (delta_clt < 0) {
    n_clt <- 0
  } else {
    sqrt_n_clt <- (-b_clt + sqrt(delta_clt)) / (2 * a_clt)
    n_clt <- floor(sqrt_n_clt^2)
   }


  return(list(markov = n_markov, chernoff = n_chernoff, clt = n_clt))
}




generate_sample_sums <- function(mu, n, K) {
  sample_sums <- replicate(K, sum(rpois(n, lambda = mu)))

  return(sample_sums)
}




run_simulation_analysis <- function(mu, n_values, K, critical_sum) {

  results_clt <- list()

  for (n in n_values) {
    cat(sprintf("n: %d\n", n))
  

    sample_means <- generate_sample_means(mu, n, K)
    plot_cdfs(sample_means, mu, n)
    max_diff <- calculate_max_cdf_diff(sample_means, mu, n)

    results_clt[[as.character(n)]] <- list(max_diff = max_diff)
    cat(sprintf("  max_diff CDF n=%d: %.4f\n", n, max_diff))
  }


  theoretical_bounds <- calculate_theoretical_n_bounds(mu, critical_sum, 0.95)
  n_clt <- theoretical_bounds$clt
  cat(sprintf("  Theoretical bounds n: Марков=%.0f, Чернов=%.0f, CLT=%.0f\n",
              theoretical_bounds$markov, theoretical_bounds$chernoff, n_clt))
  

  n_target <- floor(n_clt)
  if (is.finite(n_target) && n_target > 0) {
    cat(sprintf("n: ", n_target))


    sums_s <- generate_sample_sums(mu, n_target, K)

    empirical_prob <- sum(sums_s < critical_sum) / K
    cat(sprintf("  Empirical prob (sum %.0e) = %.4f (for n=%d)\n", critical_sum, empirical_prob, n_target))

    cat(sprintf("  Empirical prob %.4f %s is close to 0.95.\n",
                empirical_prob, ifelse(abs(empirical_prob - 0.95) < 0.02, "is", "isn't")))
  } else {
    cat("Err")
  }

}









my_team_id <- 1
molar_mass_cesium137 <- 137

calculated_mu <- calculate_poisson_param(team_id = my_team_id,
                                        molar_mass_Cs137 = molar_mass_cesium137)



run_simulation_analysis(mu = calculated_mu,
                        n_values = c(5, 10, 50),
                        K = 1000,
                        critical_sum = 8e8)



```

**Next, proceed with all the remaining steps**

**Do not forget to include several sentences summarizing your work and the conclusions you have made!**

------------------------------------------------------------------------

### Task 3.

#### In this task, we use the Central Limit Theorem approximation for continuous random variables.

#### One of the devices to measure radioactivity level at a given location is the Geiger counter. When the radioactive level is almost constant, the time between two consecutive clicks of the Geiger counter is an exponentially distributed random variable with parameter $\nu_1 = \mathtt{team\,id\,number} + 10$. Denote by $X_k$ the random time between the $(k-1)^{\mathrm{st}}$ and $k^{\mathrm{th}}$ click of the counter.

1.  Show that the distribution of the sample means of $X_1, X_2,\dots,X_n$ gets very close to a normal one (which one?) as $n$ becomes large. To this end,
    -   simulate the realizations $x_1,x_2,\dots,x_n$ of the \textbf{r.v.} $X_i$ and calculate the sample mean $s=\overline{\mathbf{x}}$;\
    -   repeat this $K$ times to get the sample $\mathbf{s}=(s_1,\dots,s_K)$ of means and then the \emph{empirical cumulative distribution} function $F_{\mathbf{s}}$ of $\mathbf{s}$;\
    -   identify $\mu$ and $\sigma^2$ such that the \textbf{c.d.f.} of $\mathscr{N}(\mu,\sigma^2)$ is close to the \textbf{e.c.d.f.} $F_{\mathbf{s}}$ of and plot both \textbf{c.d.f.}'s on one graph to visualize their proximity;\
    -   calculate the maximal difference between the two \textbf{c.d.f.}'s;\
    -   consider cases $n = 5$, $n = 10$, $n=50$ and comment on the results.
2.  The place can be considered safe when the number of clicks in one minute does not exceed $100$. It is known that the parameter $\nu$ of the resulting exponential distribution is proportional to the number $N$ of the radioactive samples, i.e., $\nu = \nu_1*N$, where $\nu_1$ is the parameter for one sample. Determine the maximal number of radioactive samples that can be stored in that place so that, with probability $0.95$, the place is identified as safe. To do this,
    -   express the event of interest in terms of the \textbf{r.v.} $S:= X_1 + \cdots + X_{100}$;\
    -   obtain the theoretical bounds on $N$ using the Markov inequality, Chernoff bound and Central Limit Theorem and compare the results;\
    -   with the predicted $N$ and thus $\nu$, simulate the realization $x_1,x_2,\dots,x_{100}$ of the $X_i$ and of the sum $S = X_1 + \cdots + X_{100}$;\
    -   repeat this $K$ times to get the sample $\mathbf{s}=(s_1,\dots,s_K)$ of total times until the $100^{\mathrm{th}}$ click;\
    -   estimate the probability that the location is identified as safe and compare to the desired level $0.95$

#### First, generate samples an sample means:

```{r}
nu1 <- 51
K <- 1e3
n <- 50
sample_means <- colMeans(matrix(rexp(n*K, rate = nu1), nrow = n))
```

#### Next, calculate the parameters of the standard normal approximation

```{r}
calc_sample_means<- function(n, K, nu1){
  mu <- 1/nu1
  sigma <- 1/(nu1 * sqrt(n))
  sample_means <- colMeans(matrix(rexp(n*K, rate = nu1), nrow = n))
  return(list(
    sample_means = sample_means,
    mu = mu,
    sigma = sigma,
    n = n
  ))
}
```

#### We can now plot ecdf and cdf

```{r}
plot_comparison <- function(result) {
  sample_means <- result$sample_means
  mu <- result$mu
  sigma <- result$sigma
  n <- result$n
  
  xlims <- c(mu-3*sigma,mu+3*sigma)
  Fs <- ecdf(sample_means)
  
  plot(Fs, 
       xlim = xlims, 
       col = "blue",
       lwd = 2,
       main = paste("Comparison of ecdf and cdf for n=", n),
        xlab = "Sample Mean",
       ylab = "Cumulative Probability")
      
  curve(pnorm(x, mean = mu, sd = sigma), col = "red", lwd = 2, add = TRUE)
  grid()
}
plot_comparison(calc_sample_means(n, K, nu1))
  
```

**Next, proceed with all the remaining steps**

**Do not forget to include several sentences summarizing your work and the conclusions you have made!**

Now we can calculate the maximal difference between the two CDF's

```{r}
calculate_max_difference <- function(result) {
  sample_means <- result$sample_means
  mu <- result$mu
  sigma <- result$sigma
  
  ks_test <- ks.test(sample_means, "pnorm", mean = mu, sd = sigma)
  
  max_diff <- ks_test$statistic  # The maximum distance D
  p_value <- ks_test$p.value     # Probability of seeing this difference by chance
  
  return(list(
    max_diff = max_diff,  # How far apart the distributions are
    p_value = p_value     # Is this difference statistically significant?
  ))
}
calculate_max_difference(calc_sample_means(n, K, nu1))


```

Let's analyze for different n

```{r}
par(mfrow = c(1, 3), mar = c(5, 4, 4, 2) + 0.1, oma = c(0, 0, 2, 0))
n_values <- c(5, 10, 50)
results <- list()
for (i in 1:length(n_values)) {
  n <- n_values[i]
  cat("Analysis for n =", n, "\n")
  result <- calc_sample_means(n, K, nu1)
  results[[i]] <- result
  
  cat("Parameters of normal approximation:\n")
  cat("  mu (mean) =", result$mu, "\n")
  cat("  sigma (std dev) =", result$sigma, "\n\n")
  plot_comparison(result)
  diff_result <- calculate_max_difference(result)
  cat("Maximum difference (KS statistic):", diff_result$max_diff, "\n")
  cat("KS test p-value:", diff_result$p_value, "\n\n")
}
```
Task 3.2
Simulation with predicteed n
```{r}
nu1 <- 51  # rate parameter for one sample (from Part 1)
n_clicks <- 100  # number of clicks threshold
time_limit <- 1  # 1 minute (60 seconds, we'll use minutes as unit)
desired_prob <- 0.95  # desired safety probability


N_markov <- 2000 / nu1
cat("  N_Markov <=", floor(N_markov), "\n\n")


chernoff_bound <- function(N_val, nu1, alpha = 0.05) {
  nu <- nu1 * N_val
  mu <- 100 / nu  # E[S]
  
  if (mu >= 1) {
    return(1)  # Bound is trivial
  }
  
  # Optimal t for Chernoff bound on P(S <= 1)
  # For Gamma distribution with a < mu, the bound involves solving
  # We use the approximation: t* = nu * (1 - 1/mu)
  t_star <- nu - 100  # Optimal t
  
  if (t_star <= 0) {
    return(1)
  }
  
  # Chernoff bound value
  bound <- (nu / (nu - t_star))^100 * exp(-t_star * 1)
  return(bound)
}

# Binary search for N using Chernoff bound
N_test <- seq(1, 50, by = 0.1)
chernoff_bounds <- sapply(N_test, function(N) chernoff_bound(N, nu1, 0.05))
N_chernoff <- max(N_test[chernoff_bounds <= 0.05])
cat("  N_Chernoff <=", floor(N_chernoff), "\n")


z_005 <- qnorm(0.05)
nu_max_clt <- 100 + 10 * z_005
N_clt <- nu_max_clt / nu1

cat("  z_0.05 =", round(z_005, 4), "\n")
cat("  nu_max =", round(nu_max_clt, 4), "\n")
cat("  N_CLT <=", floor(N_clt), "\n\n")


find_exact_N <- function(nu1, alpha = 0.05, time_limit = 1) {
  # Start with reasonable bounds
  # We know E[S] = 100/nu, so if we want E[S] > 1, then nu < 100
  # For safety with probability 0.95, nu should be even smaller
  N_lower <- 0
  N_upper <- 2  # Start with small upper bound since nu1 = 51 is large
  
  # Find upper bound more carefully
  while (N_upper < 10) {
    nu_test <- nu1 * N_upper
    prob_test <- pgamma(time_limit, shape = 100, rate = nu_test)
    
    # Check for NaN
    if (is.nan(prob_test) || prob_test <= alpha) {
      break
    }
    N_upper <- N_upper + 0.5
  }
  
  # Binary search
  tolerance <- 0.001
  while (N_upper - N_lower > tolerance) {
    N_mid <- (N_lower + N_upper) / 2
    nu_mid <- nu1 * N_mid
    prob <- pgamma(time_limit, shape = 100, rate = nu_mid)
    
    # Handle NaN cases
    if (is.nan(prob)) {
      N_upper <- N_mid
    } else if (prob <= alpha) {
      N_lower <- N_mid
    } else {
      N_upper <- N_mid
    }
  }
  
  return(N_lower)
}

N_exact <- find_exact_N(nu1, 0.05, 1)
cat("  N_exact =", floor(N_exact), "\n\n")


results_df <- data.frame(
  Method = c("Markov Inequality", "Chernoff Bound", "Central Limit Theorem", "Exact (Gamma)"),
  N_max = floor(c(N_markov, N_chernoff, N_clt, N_exact)),
  nu_max = floor(c(N_markov, N_chernoff, N_clt, N_exact)) * nu1,
  Type = c("Very Conservative", "Conservative", "Good Approximation", "Optimal")
)

print(results_df)



N_predicted <- floor(N_clt)
nu_predicted <- nu1 * N_predicted
K <- 10000  # number of simulations

cat("Using N =", N_predicted, "(from CLT)\n")
cat("Thus nu =", nu_predicted, "\n")
cat("Running", K, "simulations...\n\n")

# Simulate K times
set.seed(123)  # for reproducibility
simulate_clicks <- function(nu, n_clicks, K) {
  # Generate all samples at once for efficiency
  all_samples <- rexp(n_clicks * K, rate = nu)
  sample_matrix <- matrix(all_samples, nrow = n_clicks)
  
  # Sum each column to get S values
  S_samples <- colSums(sample_matrix)
  
  return(S_samples)
}

S_samples <- simulate_clicks(nu_predicted, n_clicks, K)

```
Find safe s
```{r}

n_safe <- sum(S_samples > time_limit)
prob_safe_simulated <- n_safe / K

#P(S = 1) for comparison
n_unsafe <- sum(S_samples <= time_limit)
prob_unsafe_simulated <- n_unsafe / K

cat("Number of safe outcomes (S > 1):", n_safe, "out of", K, "\n")
cat("Estimated P(Safe) = P(S > 1) =", round(prob_safe_simulated, 4), "\n")
cat("Estimated P(Unsafe) = P(S <= 1) =", round(prob_unsafe_simulated, 4), "\n\n")

cat("COMPARISON WITH DESIRED LEVEL:\n")
cat("Desired P(Safe) >= 0.95\n")
cat("Simulated P(Safe) =", round(prob_safe_simulated, 4), "\n")
cat("Difference:", round(prob_safe_simulated - desired_prob, 4), "\n\n")

if (prob_safe_simulated >= desired_prob) {
  cat("✓ SUCCESS: Simulated probability meets the requirement!\n\n")
} else {
  cat("✗ WARNING: Simulated probability below requirement.\n")
  cat("  Consider using N =", floor(N_exact), "for safety.\n\n")
}

# Theoretical probability for comparison
prob_safe_theoretical <- 1 - pgamma(time_limit, shape = n_clicks, rate = nu_predicted)
cat("Theoretical P(Safe) with N =", N_predicted, ":", round(prob_safe_theoretical, 4), "\n\n")



```

Visualization for 3.2
```{r}
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2) + 0.1)

# Plot 1: Histogram of S values
hist(S_samples, 
     breaks = 50, 
     probability = TRUE,
     col = "lightblue",
     border = "white",
     main = paste("Distribution of S (N =", N_predicted, ")"),
     xlab = "Total time S (minutes)",
     ylab = "Density")

# Add theoretical Gamma density
x_seq <- seq(min(S_samples), max(S_samples), length.out = 200)
lines(x_seq, dgamma(x_seq, shape = n_clicks, rate = nu_predicted), 
      col = "red", lwd = 2)

# Add vertical line at time limit
abline(v = time_limit, col = "darkgreen", lwd = 2, lty = 2)

# Shade the unsafe region
x_unsafe <- seq(0, time_limit, length.out = 100)
y_unsafe <- dgamma(x_unsafe, shape = n_clicks, rate = nu_predicted)
polygon(c(0, x_unsafe, time_limit), c(0, y_unsafe, 0), 
        col = rgb(1, 0, 0, 0.3), border = NA)

legend("topright", 
       legend = c("Simulated", "Theoretical Gamma", "Time Limit", "Unsafe Region"),
       col = c("lightblue", "red", "darkgreen", rgb(1, 0, 0, 0.3)),
       lwd = c(10, 2, 2, 10),
       lty = c(1, 1, 2, 1))

# Plot 2: Comparison of methods
methods <- c("Markov", "Chernoff", "CLT", "Exact")
N_values <- c(N_markov, N_chernoff, N_clt, N_exact)

barplot(N_values,
        names.arg = methods,
        col = c("red", "orange", "lightgreen", "darkgreen"),
        main = "Maximum N by Different Methods",
        ylab = "Maximum Number of Samples (N)",
        ylim = c(0, max(N_values) * 1.2))

# Add value labels on bars
text(x = seq(0.7, by = 1.2, length.out = 4), 
     y = N_values + max(N_values) * 0.05,
     labels = floor(N_values),
     cex = 1.2, font = 2)

abline(h = N_exact, col = "darkgreen", lty = 2, lwd = 2)

```
------------------------------------------------------------------------

### Task 4.

**This task consists of two parts:**

1.  **In this part, we discuss independence of random variables and its moments: expectation and variance.**

    1.  Suppose we have a random variable $X$. Explain why $\mathbb{E}(\frac{1}{X}) \neq \frac{1}{\mathbb{E(X)}}$; Answer: because for X - continuous r.v: $E(g(X)) = \int_{-\infty}^{\infty} g(x) \cdot f_{X}(x) \,dx$, X - discrete r.v: $E(g(X)) = \sum_{i} g(x_{i}) \cdot P(X=x_{i})$, and for non X $E(g(X)) = g(E(X))$

    2.  Let $X \sim \mathscr{N}(\mu,\sigma^2)$ with $\mu = teamidnumber$ and $\sigma^{2} = 2\times teamidnumber+7$. Simulate realizations $x_1,x_2,\dots,x_{100}$ of $X$ and $y_1,y_2,\dots,y_{100}$ of $Y := \frac{1}{X}$ to calculate the values of $\frac{1}{\overline{\textbf{X}}}$ and $\overline{\textbf{Y}}$. Comment on the received results;

    ```{r}
    mu <- id
    sigma <- sqrt(2*id+7)
    N <- 100

    # YOUR CODE HERE
    x_vals <- rnorm(N, mean = mu, sd = sigma)
    y_vals <- 1 / x_vals

    mean_x <- mean(x_vals)
    val1 <- 1 / mean_x

    val2 <- mean(y_vals)

    print(paste("μ =", mu, "and σ^2 =", sigma^2))
    print(paste("1 / X_bar (1/mean(X)):", val1))
    print(paste("Y_bar (mean(Y) or mean(1/X)):", val2))
    ```

    1/mean(X)) and mean(1/X), are not equal. This is the main takeaway.

    3.  Let $X$ and $Y$ be exponentially distributed r.v.'s with parameter $\lambda = 2$. Set $Z := \log{X} + 5$. Plot the Quantile-Quantile plot and scatterplot of $X$ and $Y$. Plot the Quantile-Quantile plot and scatterplot of $X$ and $Z$. Explain the results. Comment on the difference of relations between the pairs of random variables. Which pair of r.v.'s is dependent and which one is similar?

    ```{r}
    # YOUR CODE HERE
    N <- 1000
    lambda <- 2
    set.seed(id)

    x <- rexp(N, rate = lambda)
    y <- rexp(N, rate = lambda)

    z <- log(x) + 5

    par(mfrow = c(2, 2), mar = c(4.5, 4.5, 3, 1.5))

    plot(x, y, main = "Scatterplot of X and Y",
         xlab = "X", ylab = "Y",
         pch = 19, col = alpha("blue", 0.3))
    cor_xy <- cor(x, y)
    legend("topright", legend = paste("Cor =", round(cor_xy, 4)), bty = "n")

    qqplot(x, y, main = "QQ Plot of X and Y",
           xlab = "X Quantiles", ylab = "Y Quantiles",
           pch = 19, col = alpha("blue", 0.3))
    abline(0, 1, col = "red", lwd = 2)

    plot(x, z, main = "Scatterplot of X and Z",
         xlab = "X", ylab = "Z = log(X) + 5",
         pch = 19, col = alpha("darkgreen", 0.3))
    cor_xz <- cor(x, z)
    legend("bottomright", legend = paste("Cor =", round(cor_xz, 4)), bty = "n")

    qqplot(x, z, main = "QQ Plot of X and Z",
           xlab = "X Quantiles", ylab = "Z Quantiles",
           pch = 19, col = alpha("darkgreen", 0.3))
    abline(0, 1, col = "red", lwd = 2)
      
    par(mfrow = c(1, 1))
    ```

For X and Y we see on scatterplot a shapeless set of points denser near the origin, it is as this because knowing the value of one r.v doesn't give any information about another. Correlation is very close to zero. On Quantile-Quantile plot (QQ plot) we can see how points almost perfectly align with y=x line. It is expected, as they are identically distributed. For X and Y we see on scatterplot that they depend on each other with correlation of $\approx 0.78$ which only describes the strength of linear relationship, but we can see very clear logarithmic curve, what shows that the value of one variable definitely depend on the value of another variable as we see some function graph, not a chaos. On the QQ plot we see how quantiles of X and Z doesn't match at all, what is expected as they have completely different distribution.

```         
------------------------------------------------------------------------
```

2.  You toss a fair coin three times and a random variable $X$ records how many times the coin shows Heads. You convince your friend that they should play a game with the following payoff: every round (equivalent to three coin tosses) will cost £$1$. They will receive £$0.5$ for every coin showing Heads. What is the expected value and the variance of the random variable $Y := 0.5X-1$?

    To answer this,

    1.  Explain what type of random variable is X: X is a Binomially distributed random variable, as we have a fixed number of trials, each trial is independent, each trial has only 2 possible outcomes (success or failure), probability of success is constant p=0.5

    2.  What are the expected value and variance of X? Simulate realizations $x_1,x_2,\dots,x_{100}$ of $X$ to calculate the values of sample mean $\overline{\mathbf{X}}$ and sample variance $s^2 = \frac{\sum_{i=1}^{n}{(x_i - \overline{x})^{2}}}{n-1}$. Comment on the results;

    ```{r}
    n_trials <- 3
    p_success <- 0.5
    N <- 100
    set.seed(id)

    x_realizations <- rbinom(N, size = n_trials, prob = p_success)

    sample_mean_x <- mean(x_realizations)
    sample_variance_x <- var(x_realizations) # uses the same formula Var(x) = sum((xi-mean)^2)/(n-1)

    print(paste("Theoretical E(X):", 1.5))
    print(paste("Sample Mean (X-bar):", sample_mean_x))

    print(paste("Theoretical Var(X):", 0.75))
    print(paste("Sample Variance (s^2):", sample_variance_x))
    ```

    The sample mean X is very close to the theoretical expected value E(X) (1.5). The sample variance is also not so far from theoretical variance (0.75). As N=100 is relatively small our mean and variance is close to the theoretical but not very. For example, for N = 100000 we will have a result that differenciate from the theoretical for not so much, that works like that because of the Law of Large Numbers

    ```{r}
    N = 100000
    set.seed(id)
    x_realizations <- rbinom(N, size = n_trials, prob = p_success)

    sample_mean <- mean(x_realizations)
    sample_variance <- var(x_realizations) # uses the same formula Var(x) = sum((xi-mean)^2)/(n-1)

    print(paste("Theoretical E(X):", 1.5))
    print(paste("Sample Mean (X-bar):", sample_mean))

    print(paste("Theoretical Var(X):", 0.75))
    print(paste("Sample Variance (s^2):", sample_variance))
    ```

    3.  What are the expected value and variance of Y? Simulate realizations $y_1,y_2,\dots,y_{100}$ of $Y$ to calculate the values of sample mean $\overline{\mathbf{Y}}$ and sample variance $s^2 = \frac{\sum_{i=1}^{n}{(y_i - \overline{y})^{2}}}{n-1}$. Comment on the results;

    ```{r}
    # YOUR CODE HERE
    n_trials <- 3
    p_success <- 0.5
    N <- 100
    set.seed(id)

    x_realizations <- rbinom(N, size = n_trials, prob = p_success)

    y_realizations <- 0.5 * x_realizations - 1

    sample_mean_y <- mean(y_realizations)

    sample_variance_y <- var(y_realizations)

    print(paste("Theoretical E(Y):", -0.25))
    print(paste("Sample Mean (Y-bar):", sample_mean_y))

    print(paste("Theoretical Var(Y):", 0.1875))
    print(paste("Sample Variance (s^2):", sample_variance_y))
    ```

    The sample mean and variance is also pretty close to the theoretical one. But more interesting is that the transformation rules hold very nice:

    ```{r}
    transfomed_y_mean = 0.5*sample_mean_x - 1
    transformed_y_variance = 0.25*sample_variance_x

    print(paste("Sample mean y calculated:", sample_mean_y))
    print(paste("Sample mean y transformed:", transfomed_y_mean))
    print(paste("Sample variance y calculated:", sample_variance_y))
    print(paste("Sample mean y transformed:", transformed_y_variance))
    ```

------------------------------------------------------------------------

### General summary and conclusions

Summarize here what you've done, whether you solved the tasks, what difficulties you had etc.
